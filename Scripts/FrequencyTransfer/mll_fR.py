# -*- coding: utf-8 -*-
"""
Created on Fri Jul 21 15:51:36 2017

@author: Connor
"""

# %% Import Moduless ==========================================================

import numpy as np
from scipy.optimize import curve_fit
import matplotlib.pyplot as plt
import time
import logging

from Drivers.Logging import EventLog as log

from Drivers.Database import MongoDB
from Drivers.Database import CouchbaseDB

from Drivers.VISA.SRS import SIM960
from Drivers.VISA.ILXLightwave import TECModule
from Drivers.VISA.Thorlabs import MDT639B

from Drivers.DAQ.Tasks import AiTask


# %% Helper Functions =========================================================

# Get Values from Nested Dictionary -------------------------------------------
def from_keys(nested_dict, key_list):
    if isinstance(key_list, list):
        for key in key_list:
            nested_dict = nested_dict[key]
    else:
        nested_dict = nested_dict[key_list]
    return nested_dict

# Parse and Send Arguments to Functions ---------------------------------------
def send_args(func, obj=None):
    if isinstance(obj, list):
        args = obj
        kwargs = {}
    elif isinstance(obj, dict):
        args = []
        kwargs = obj
    elif isinstance(obj, tuple):
        args = obj[0]
        kwargs = obj[1]
    elif obj == None:
        args = []
        kwargs = {}
    else:
        args = [obj]
        kwargs = {}
    result = func(*args, **kwargs)
    return result

# Exhaust a MongoDB Cursor to Queue up the Most Recent Values -----------------
def exhaust_cursor(cursor):
    for doc in cursor:
        pass
    return cursor

# Convert Type from a "type string" -------------------------------------------
def convert_type(obj, type_str):
    valid_types = {'bool':bool, 'complex':complex,
                   'float':float, 'int':int, 'str':str}
    obj = valid_types[type_str](obj)
    return obj
        

# %% Databases and Settings ===================================================

# Communications queue --------------------------------------------------------
'''The communications queue should be a database that serves as the
    intermediary between this script and others. The entries in this queue
    are parsed as commands in this script:
        Requesting to change state:
            {'state': {<state DB path>:{'state':<state>},...}}
        Requesting to change device settings:
            {'device_setting': {<device driver DB path>:{<method name>:<args>,...},...}}
        Requesting to change a control parameter:
            {'control_parameter': {<local method>:{<parameter name>:<value>,...},...}}
    -Commands are sent into the queue by setting the "message" keyword argument
    within the CouchbaseDB queue.push() method. 
    -Commands are read from the queue with the queue.pop() method.
    -If the DB path given does not exist in the defined STATE_DBs and
    DEVICE_DBs, or the given method and parameter does not exist in 
    CONTROL_PARAMS, no attempt is made to excecute the command.
    -All commands are caught and logged at the INFO level.
    -Multiple commands may be input simultaneously by nesting single commands
    within the 'state', 'device_setting', and 'control_parameter' keys:
        message = {
            'state':{<state DB path>:{'state':<state>},...},
            'device_setting':{<device driver DB path>:{<method name>:<args>,...},...},
            'control_parameter':{<local method>:{<parameter name>:<value>,...},...}}
    '''
COMMS = 'mll_fR'

# Local database names --------------------------------------------------------
'''The following are all of the databases that this script directly
    controls. Each of these databases are initialized within this script.
    The databases should be grouped by function:
        state:
            -The entries in state databases should reflect the current state of
            the system and the level of compliance. Other scripts should look
            to these databases in order to resolve prerequisites.
        device:
            -The entries in visa databases should include the settings for
            each unique device or device/channel combination.
        monitor:
            -The entries in monitor databases should contain secondary 
            variables used to determine compliance with the state of the 
            system, and to determine any actions required to maintain
            compliance. In general, data for use in control loops should have
            an updated value every 0.2 seconds. Data for passive monitoring
            should have a relaxed 1.0 second or longer update period.
        log:
            -This should be a single database that serves as the repository of
            all logs generated by this script.
        control:
            -This should be a single database that contains all control loop 
            variables accessible to commands from the comms queue.'''
STATE_DBs = [
    'mll_fR/state']
DEVICE_DBs =[
    'mll_fR/settings_TEC', 'mll_fR/settings_PID',
    'mll_fR/settings_HV', 'mll_fR/settings_DAQ_ErrorFrequency']
MONITOR_DBs = [
    'mll_fR/TEC_temperature', 'mll_fR/TEC_current', 'mll_fR/PID_voltage', 
    'mll_fR/HV_output', 'mll_fR/rms_error']
LOG_DB = 'mll_fR/log'
CONTROL_DB = 'mll_fR/control'
MASTER_DBs = STATE_DBs + DEVICE_DBs + MONITOR_DBs + [LOG_DB] + [CONTROL_DB]

# External database names -----------------------------------------------------
'''This is a list of all databases external to this control script that are 
    needed to check prerequisites'''
R_STATE_DBs = []
R_DEVICE_DBs =[]
R_MONITOR_DBs = []
READ_DBs = R_STATE_DBs + R_DEVICE_DBs + R_MONITOR_DBs

# Default settings ------------------------------------------------------------
'''A template for all settings used in this script. Upon initialization 
    these settings are checked against those saved in the database, and 
    populated if found empty. Each state and device database should be
    represented. Default values are only added to a database if they are found 
    to be undefined within the database:
        states:
            -Entries in the state databases are specified as follows:
                {<state database path>:{
                'state':<name of the current state>,
                'prerequisites':{
                        'critical':<critical>,
                        'necessary':<necessary>,
                        'optional':<optional>},
                'compliance':<compliance of current state>
                'desired_state':<name of the desired state>,
                'initialized':<initialization state of the control script>},...}
            -The state name should correspond to one of the defined states.
            -The prerequisites should be a 3 part dictionary of boolean values
            that indicates whether the prerequisites pass for the current
            state. The 3 severity levels are critical, necessary, and optional.
            -The compliance level should be a boolean value that indicates
            whether the system is compliant with the current state.
            -The "desired_state" is mostly for internal use, particularly for
            cases where the state is temporarliy changed. The script should
            seek to bring the current state to the desired state. The script 
            should not change the current state if the desired state is
            undefined.
            -The "initialized" parameter is a boolean value that indicates that
            the current state is accurate. This is useful for cases where a
            master program or watchdog starts the control scripts. It should
            be set to False by the master program before the control scripts
            are executed, and should only be set to True after the
            control scripts have determined the current state. In order to 
            smoothly connect to the system if the instruments are already 
            running, initialization prerequisites should be either
            "necessary" or "optional".
        devices:
            -Entries in the device databases are specified as follows:
                {<device database path>:{
                    {<method name>:<args>,...},...}
            -The entries should include the settings for each unique device or
            device/channel combination. 
            -For automation purposes, the setting names and parameters should
            be derived from the methods of the device drivers.
            -Place multiple arguments in a list, keyword arguments in
            dictionaries, and combinations of the two in tuples:
                ([args], {kwargs})
            -Single arguments may be left as is, but single arguments that are
            lists must nested one level deep:
                [[list argument]]
            -The automated "send_args()" checks whether the instance is a list,
            a dictionary, a tuple, or is None before sending the commands.
        control parameter:
            -Entries in the control parameter database are specified follows:
                {<control database path>:{
                    <local method>:{
                        <control parameter>:{'value':<value>,'type':<type str>},...}
                    ,...}}
            -Control parameters are grouped by the method that they contribute
            to. Choose one method in which to associate a single control
            parameter if it happens to be used in multiple local methods. These
            methods are executed based on their placement in STATES.
            -Control parameters have both a value and a type.
            -Only include parameters that should have remote access.'''
STATE_SETTINGS = {
        'mll_fR/state':{
                'state':'engineering',
                'prerequisites':{
                        'critical':False,
                        'necessary':False,
                        'optional':False},
                'compliance':False,
                'desired_state':'lock',
                'initialized':False}}
DEVICE_SETTINGS = {
        # VISA device settings
        'mll_fR/settings_TEC':{
                '__init__':['visa address', 'channel'],
                'tec_off_triggers':[[5, 6, 7, 8, 10]], 'tec_gain':100, 
                'tec_current_limit':0.400, 'tec_temperature_limit':40.0, 'tec_mode':'R',
                'tec_output':True, 'tec_resistance_setpoint':7.580},
        'mll_fR/settings_PID':{
                '__init__':['visa address', 'port'],
                'proportional_action':True, 'integral_action':True,
                'derivative_action':False, 'offset_action':False, 
                'proportional_gain':-3.0e0, 'integral_gain':5.0e2, 'pid_action':False,
                'setpoint_action':False, 'internal_setpoint':0.000, 'ramp_action':False,
                'manual_output':0.000, 'upper_output_limit':8.00,
                'lower_output_limit':0.00, 'power_line_frequency':60, 'display':True},
        'mll_fR/settings_HV':{
                '__init__':'<visa address>',
                'x_min':0.00, 'x_max':60.00, 'x_voltage':0.00},
        # DAQ settings
        'mll_fR/settings_DAQ_ErrorFrequency':{
                '__init__':(
                        [[{'physical_channel':'Dev1/ai0', 'terminal_config':'NRSE',
                           'min_val':-1.0, 'max_val':1.0}], 10e3, int(10e3*0.1)],
                        {'timeout':5.0}),
                'reserve_cont':False, 'reserve_point':False, 'read_point':10000}}
CONTROL_PARAMS = {
        'mll_fR/control':{ }}
SETTINGS = dict(list(STATE_SETTINGS.items()) + list(DEVICE_SETTINGS.items()) + list(CONTROL_PARAMS.items()))

# %% Initialize Databases, Devices, and Settings ==============================

# Connect to MongoDB ----------------------------------------------------------
'''Creates a client and connects to all defined databases'''
mongo_client = MongoDB.MongoClient()
db = {}
for database in MASTER_DBs:
    db[database] = mongoDB.DatabaseMaster(mongo_client, database)

for database in READ_DBs:
    db[database] = mongoDB.DatabaseRead(mongo_client, database)

# Initialize all Database Settings --------------------------------------------
'''This checks that all settings (as listed in SETTINGS) exist within the
    databases. Any missing settings are populated with the default values.'''
for database in SETTINGS:
    initialized = True
    settings_in_db = db[database].read_buffer()
    for setting in SETTINGS[database]:
    # Check that the key exists in the database
        if not(setting in settings_in_db):
            initialized = False
            settings_in_db[setting] = SETTINGS[database][setting]
    if not(initialized):
    # Update the database values if necessary
        db[database].write_record_and_buffer(settings_in_db)

# Start Logging ---------------------------------------------------------------
'''Initializes logging for this script. If the logging database is unset then
    all logs will be output to the stout. There are two logging handlers when 
    the logging database is set, one logs lower threshold events to the log 
    buffer and the other logs warnings and above to the permanent log database.
    The threshold for the base logger, and the two handlers, may be set in the
    following command.'''
log.start_logging(logger_level=logging.DEBUG) #database=db[LOG_DB])

# Connect to the Communications Queue -----------------------------------------
'''Creates a handle for the queue object defined by COMMS'''
comms = CouchbaseDB.PriorityQueue(COMMS)

# Initialize Devices ----------------------------------------------------------
'''Each device database should be associated with a driver and a queue. The 
    format is as follows:
        dev[<device database path>] = {
                'driver':<driver object>,
                'queue':<queue objecct>}
    -The queue is needed to coordinate access to the devices. Each blocking
    connection to a device should have a unique queue. If access to one part of
    an instrument blocks access to other parts, that set of parts should all
    use the same unique queue.'''
dev = {}
    # VISA drivers
dev['mll_fR/settings_TEC'] = {
        'driver':send_args(TECModule, DEVICE_SETTINGS['mll_fR/settings_TEC']['__init__']),
        'queue':CouchbaseDB.PriorityQueue('<visa address>')}
dev['mll_fR/settings_PID'] = {
        'driver':send_args(SIM960, DEVICE_SETTINGS['mll_fR/settings_PID']['__init__']),
        'queue':CouchbaseDB.PriorityQueue('<visa address>')}
dev['mll_fR/settings_HV'] = {
        'driver':send_args(MDT639B, DEVICE_SETTINGS['mll_fR/settings_HV']['__init__']),
        'queue':CouchbaseDB.PriorityQueue('<visa address>')}
    # DAQ drivers
dev['mll_fR/settings_DAQ_ErrorFrequency'] = {
        'driver':send_args(AiTask, DEVICE_SETTINGS['mll_fR/settings_DAQ_ErrorFrequency']['__init__']),
        'queue':CouchbaseDB.PriorityQueue('<daq type and/or channels>')}

# Initialize a Local Copy of Device Settings and Control Parameters -----------
'''This pulls the most recent values from the databases for use in this scipt.'''
local_settings = {}
for database in SETTINGS:
    local_settings[database] = db[database].read_buffer()

# Initialize Local Copy of Monitors -------------------------------------------
'''Monitors should associate the monitor databases with the local, circular
    buffers of the monitored data. Monitors from the read database should have
    their cursors exhausted so that only their most recent values are 
    accessible:
        {<database path>:{'data':<placeholder for local data copy>},
                          'cursor':<tailable cursor object>}'''
local_mon = {}
for database in MONITOR_DBs:
    mon[database] = {'data':np.array([]), 'cursor':None}

for database in R_MONITOR_DBs:
    cursor = db[database].read_buffer(tailable_cursor=True, no_cursor_timeout=True)
    mon[database] = {'data':np.array([]), 'cursor':exhaust_cursor(cursor)}


# %% State and Monitor Functions ==============================================

# Do nothing function ---------------------------------------------------------
'''A functional placeholder for cases where nothing should happen.'''
def nothing():
    pass

# Monitor Functions -----------------------------------------------------------
'''This section is for defining the methods needed to monitor the system.'''


# Search Functions ------------------------------------------------------------
'''This section is for defining the methods needed to bring the system into
    its defined states.'''

    
# Maintain Functions ----------------------------------------------------------
'''This section is for defining the methods needed to maintain the system in
    its defined states.'''


# Operate Functions -----------------------------------------------------------
'''This section is for defining the methods called only when the system is in
    its defined states.'''



# %% States ===================================================================
'''Defined states are composed of collections of settings, prerequisites,
    and routines:
        settings:
            -Only the settings particular to a state need to be listed, and
            they should be in the same format as those in SETTINGS:
                'settings':{
                    <device database path>:{
                        <method>:<args>,...},...}
            -The settings listed here should be thought of as stationary
            prerequisites, or as known initialization states that the system
            should pass through to ease the transition to the compliant state.
            -Dynamic settings should be dealt with in the state's methods.
            -These settings will be applied before the system transitions from
            one state to the next.
        prerequisites:
            -Prerequisites should be entered as lists of dictionaries that
            include the database and key:value pair that corresponds to a
            passing prerequisite for the given state:
                'prerequisites':{
                    {'critical':[{
                        'db':<database path>,
                        'key':<entry's key>,
                        'value':<desired value>},...],
                    'necessary':[{...},...],
                    'optional':[{...}]}}
            -The automated "from_keys()" checks for lists of keys needed to
            retrieve values from nested dictionaries.
            -Prereqs should be separated by severity:
                critical:
                    -A failed critical prereq could jeopardize the health of
                    the system if brought into or left in the applied state.
                    -Critical prerequisites are continuously monitored.
                    -The system is placed into a temporary "safe" state upon 
                    failure of a critical prereq.
                necessary:
                    -Failure of a necessary prereq will cause the system to 
                    come out of, or be unable to reach, compliance.
                    -Necessary prereqs are checked if the system is out
                    of compliance.
                    -The system is allowed to move into the applied state upon 
                    failure of a necessary prereq, but no attempts are made to
                    bring the system into compliance.
                optional:
                    -Failure of an optional prereq should not cause failure
                    elsewhere, but system performance or specifications can't
                    be guaranteed. Think of it more as "non compulsory" than
                    "optional".
                    -Optional prereqs are checked when the system is out of
                    compliance, and when the system is in compliance, but the
                    optional prereqs are listed as failed.
                    -The system is allowed to move into the applied state upon 
                    failure of an optional prereq.
        routines:
            -The routines are the functions needed to monitor the state, bring
            the state into compliance, maintain the state in compliance, and
            operate any other scripts that require a compliant state. 
            -All routines must accept the path of a state DB as an argument:
                routine(<state database path>)
            -Only one function call should be listed for each method. The 
            methods themselves may call others.
            -Routines should be entered for the 4 cases:
                'routines':{
                    'monitor':<method>, 'search':<method>,
                    'maintain':<method>, 'operate':<method>}
            monitoring:
                -The monitor method should update all state parameters
                necessary for the "maintain" methods as well as any secondary
                parameters useful for passive monitoring.
                -Updating state parameters includes getting new values from
                connected instruments and pulling new values from connected
                databases. 
                -New values from instruments should always be saved to their
                respective databases.
                -Suggested refresh times for control loop parameters is 0.2
                seconds, while a 1.0 second or longer refresh time should be
                sufficient for passive monitoring parameters.
                -All values should be stored locally in circular buffers. The
                sizes of should be controlled within these methods.
            searching:
                -The search method should be able to bring the system into
                compliance from any noncompliant state. 
                -The most important cases to consider are those starting from
                the configuration as given in the state's "settings", and the
                cases where the state has transitioned from a compliant to a
                noncompliant state.
                -It is the search method's responsibility to change the state's 
                compliance state variable as the "maintain" and "operate"
                scripts are only called if the state's compliance variable is
                set to True.
                -The search method should use testing criteria to determine if the
                found state is truly in compliance before setting the state's
                compliance variable.
                -The compliance state variable is accessible by calling:
                    current_state[<state database path>]['compliance']
            maintaining:
                -The maintain method should observe the state parameters and
                make any needed adjustments to the state settings in order to
                maintain the state.
                -If time series are needed in order to maintain the state, a
                global variable may be used within the maintain and search
                methods to indicate when the search method brought the state
                into compliance. The maintain method may then use that
                knowledge to selectively pull values from the "monitor" 
                buffers or simply clear the buffers on first pass.
                -The maintain method is responsible for changing the compliance
                variable to False if it is unable to maintain the state.
                -The compliance state variable is accessible by calling:
                    current_state[<state database path>]['compliance']
            operating:
                -The operate method is a catchall function for use cases that
                are only valid while the state is in compliance. An example
                could be to only read values from an instrument buffer while
                the instrument's data collection state is active.'''
STATES = {
        'mll_fR/state':{
                'lock':{
                        'settings':{
                                'mll_fR/settings_TEC':{
                                        'tec_mode':'R', 'tec_output':True},
                                'mll_fR/settings_PID':{
                                        'proportional_action':True, 'integral_action':True,
                                        'derivative_action':False, 'offset_action':False,
                                        'proportional_gain':-3.0e0, 'integral_gain':5.0e2,},
                                'mll_fR/settings_HV':{
                                        'x_min':0.00, 'x_max':60.00, 'x_voltage':0.00},
                                'mll_fR/settings_DAQ_ErrorFrequency':{}},
                        'prerequisites':{
                                'critical':[
                                        {'db':'', 'key':'entry', 'value':''}],
                                'necessary':[],
                                'optional':[]},
                        'routines':{
                                'monitor':monitor, 'search':find_lock,
                                'maintain':keep_lock, 'operate':nothing}},
                'manual':{
                        'settings':{
                                'mll_fR/settings_TEC':{},
                                'mll_fR/settings_PID':{},
                                'mll_fR/settings_HV':{},
                                'mll_fR/settings_DAQ_ErrorFrequency':{}},
                        'prerequisites':{
                                'critical':[],
                                'necessary':[],
                                'optional':[]},
                        'routines':{
                                'monitor':monitor, 'search':transfer_to_manual,
                                'maintain':nothing, 'operate':nothing}},
                'safe':{
                        'settings':{
                                'mll_fR_settings_TEC':{},
                                'mll_fR_settings_PID':{'pid_action':False},
                                'mll_fR_settings_HV':{},
                                'mll_fR/settings_DAQ_ErrorFrequency':{}},
                        'prerequisites':{
                                'critical':[],
                                'necessary':[],
                                'optional':[]},
                        'routines':{
                                'monitor':monitor, 'search':nothing,
                                'maintain':lock_disabled, 'operate':nothing}},
                'engineering':{
                        'settings':{
                                'mll_fR_settings_TEC':{},
                                'mll_fR_settings_PID':{},
                                'mll_fR_settings_HV':{},
                                'mll_fR/settings_DAQ_ErrorFrequency':{}},
                        'prerequisites':{
                                'critical':[],
                                'necessary':[],
                                'optional':[]},
                        'routines':{
                                'monitor':nothing, 'search':nothing,
                                'maintain':nothing, 'operate':nothing}}}
        }

# %% STATE MACHINE ============================================================
'''The code after this section operates the state machine.
    -All adjustments to code should be made before this section.'''
# %% Main Loop Functions ======================================================

# Check the Prerequisites of a Given State ------------------------------------
def check_prereqs(state_db, state, level):
    prereqs_pass = True
    for prereq in STATES[state_db][state]['prerequisites'][level]:
        prereq_value = from_keys(db[prereq['db']].read_buffer(),prereq['key'])
        prereqs_pass *= (prereq_value == prereq['value'])
    return prereqs_pass

# Update Device Settings ------------------------------------------------------
def update_device_settings(device_db, setting_list):
    updated = False
# Wait for queue
    queued = dev[device_db]['queue'].queue_and_wait()
# Push device settings
    for setting in setting_list:
    # Log the device, method, and arguments
        prologue_str = 'device: {:}; method: {:}; args: {:}'.format(device_db, setting, setting_list[setting])
        log.log_info(__name__, 'update_device_settings', result)
    # Try sending the command to the device
        try:
            result = send_args(getattr(dev[device_db]['driver'], setting),setting_list[setting])
        except:
            log.log_exception(__name__, 'update_device_settings')
        else:
        # Update the local copy if it exists in the device settings
            if (setting in local_settings[device_db]):
                if (local_settings[device_db][setting] != setting_list[setting]):
                    updated = True
                    local_settings[device_db][setting] = setting_list[setting]
        # Log the returned result if stringable
            try:
                epilogue_str = 'Returned: {:}'.format(str(result))
            except:
                epilogue_str = 'Returned successfully, but result was not stringable'
            log.log_info(__name__, 'update_device_settings', epilogue_str)
    # Touch queue (prevent timeout)
        dev[device_db]['queue'].touch()
# Remove from queue
    if not(queued):
        dev[device_db]['queue'].remove()
# Update the database if the local copy changed
    if updated:
        db[device_db].write_record_and_buffer(local_settings[device_db])
    
# Setup the Transition to a New State -----------------------------------------
def setup_state(state_db, state, critical=True, necessary=True, optional=True):
# Update the device settings
    for device_db in STATES[state_db][state]['settings']:
        update_device_settings(device_db, STATES[state_db][state]['settings'][device_db])
# Update the state variable
    current_state[state_db]['state'] = state
    current_state[state_db]['prerequisites'] = {
            'critical':critical,
            'necessary':necessary,
            'optional':optional}
    current_state[state_db]['compliance'] = False
    db[state_db].write_record_and_buffer(current_state[state_db]) # The desired state should be left unaltered

# Parse Messages from the Communications Queue --------------------------------
def parse_message(message):
    if ('message' in message):
        message = message['message']
        log.log_info(__name__, 'parse_message', str(message))
    # If requesting to change states,
        if ('state' in message):
            for state_db in message['state']:
                desired_state = message['state'][state_db]['state']
                if current_state[state_db]['desired_state'] != desired_state:
                # Update the state variable
                    current_state[state_db]['desired_state'] = desired_state
                    db[state_db].write_record_and_buffer(current_state[state_db])
    # If requesting to change device settings,
        if ('device_setting' in message):
            for device_db in message['device_setting']:
            # Update the device settings
                if (device_db in DEVICE_DBs):
                    update_device_settings(device_db, message['device_setting'][device_db])
    # If requesting to change control parameters,
        if ('control_parameter' in message):
            updated = False
            for method in message['control_parameter']:
                if (method in local_settings[CONTROL_DB]):
                    for parameter in message['control_parameter'][method]:
                    # Update the control parameter
                        if (parameter in local_settings[CONTROL_DB][method]):
                        # Convert new parameter to the correct type
                            parameter_type = local_settings[CONTROL_DB][method][parameter]['type']
                            try:
                                result = convert_type(message['control_parameter'][method][parameter], parameter_type)
                            except:
                                result_str = 'Could not convert {:} to {:} for control parameter {:}.{:}'.format(message['control_parameter'][method][parameter], parameter_type, method, parameter)
                                log.log_info(__name__, 'parse_message', result_str)
                            else:
                                if (local_settings[CONTROL_DB][method][parameter]['value'] != result):
                            # Update the local copy
                                    updated = True
                                    local_settings[CONTROL_DB][method][parameter]['value'] = result
        # Update the database if the local copy changed
            if updated:
                db[CONTROL_DB].write_record_and_buffer(local_settings[CONTROL_DB])

# %% Main Loop ================================================================

loop = True
while loop:
# Get the Current State -------------------------------------------------------
    current_state = {}
    for state_db in STATE_DBs:
        current_state[state_db] = db[state_db].read_buffer()
    
# Check the Critical Prerequisites --------------------------------------------
    for state_db in STATE_DBs:
        critical_pass = check_prereqs(
                state_db,
                current_state[state_db]['state'],
                'critical')
    # Place into safe state if critical prereqs fail
        if not critical_pass:
            setup_state(state_db, 'safe')

# Monitor the Current State ---------------------------------------------------
for state_db in STATE_DBs:
    STATES[state_db][current_state[state_db]]['routines']['monitor'](state_db)

# Maintain the Current State --------------------------------------------------
    for state_db in STATE_DBs:
    # If compliant,
        if current_state[state_db]['compliance'] == True:
        # If necessary, check the optional prerequisites
            if current_state[state_db]['prerequisites']['optional'] == False:
                optional_pass = check_prereqs(
                    state_db,
                    current_state[state_db]['state'],
                    'optional')
                if optional_pass == True:
                # Update the state variable
                    current_state[state_db]['prerequisites']['optional'] = optional_pass
                    db[state_db].write_record_and_buffer(current_state[state_db])
        # Maintain compliance
            STATES[state_db][current_state[state_db]]['routines']['maintain'](state_db)
    # If out of compliance, 
        else:
        # Check necessary and optional prerequisites
            necessary_pass = check_prereqs(
                    state_db,
                    current_state[state_db]['state'],
                    'necessary')
            optional_pass = check_prereqs(
                    state_db,
                    current_state[state_db]['state'],
                    'optional')
            necessary_prereq_changed = (current_state[state_db]['prerequisites']['necessary'] != necessary_pass)
            optional_prereq_changed = (current_state[state_db]['prerequisites']['optional'] != optional_pass)
            if (necessary_prereq_changed or optional_prereq_changed):
            # If necessary, update the state variable
                current_state[state_db]['prerequisites']['necessary'] = necessary_pass
                current_state[state_db]['prerequisites']['optional'] = optional_pass
                db[state_db].write_record_and_buffer(current_state[state_db])
        # Search for the compliant state
            if necessary_pass:
                STATES[state_db][current_state[state_db]]['routines']['search'](state_db)
    # Set the state initialization if necessary
        if not(current_state[state_db]['initialized']):
        # Update the state variable
            current_state[state_db]['initialized'] = True
            db[state_db].write_record_and_buffer(current_state[state_db])
    
# Operate the Current State ---------------------------------------------------
    for state_db in STATE_DBs:
    # If compliant,
        if current_state[state_db]['compliance'] == True:
            STATES[state_db][current_state[state_db]]['routines']['operate'](state_db)

# Check the Communications Queue ----------------------------------------------
    for message in range(len(comms.get_queue())):
    # Parse the message
        message = comms.pop()
        parse_message(message)
                        
# Check Desired State ---------------------------------------------------------
    for state_db in STATE_DBs:
        if current_state[state_db]['state'] != current_state[state_db]['desired_state']:
        # Check the prerequisites of the desired states
            critical_pass = check_prereqs(
                    state_db,
                    current_state[state_db]['desired_state'],
                    'critical')
            necessary_pass = check_prereqs(
                    state_db,
                    current_state[state_db]['desired_state'],
                    'necessary')
            optional_pass = check_prereqs(
                    state_db,
                    current_state[state_db]['desired_state'],
                    'optional')
            if critical_pass:
            # Initialize the transition into the desired state
                setup_state(
                        state_db,
                        current_state[state_db]['desired_state'],
                        critical=critical_pass,
                        necessary=necessary_pass,
                        optional=optional_pass)


# %% OLD STUFF
#==============================================================================
# %% Functions

def start_busy(task):
    started = False
    while not started:
        try:
            task.StartTask()
        except DAQError as daq_err:
            if daq_err.error == -50103: # "The specified resource is reserved."
                pass
            else:
                raise
        else:
            started = True


class ilx_LDC3900:
    def __init__(self, visa_id, channel, rm = None):
        print(time.strftime('%c')+' - Initializing communication with the ILX LDC-3900.')
        if rm is None:
            rm = visa.ResourceManager()
        opened = False
        while not opened:
            try:
                self.ilx = rm.open_resource(visa_id, open_timeout = 5000)
            except visa.VisaIOError as visa_err:
                if visa_err[0] == visa.VisaIOError(visa.constants.VI_ERROR_RSRC_BUSY)[0]:
                    pass
                else:
                    raise
            else:
                opened = True
        self.ilx.close()
        self.las_open_cmd = 'LAS:CHAN {:}'.format(int(channel))
        self.tec_open_cmd = 'TEC:CHAN {:}'.format(int(channel))
        self.tec_settling_time = 30 # seconds
        self.last_tec_change = time.time()
        self.nominal_tec_r = 7.7
        self.safe_tec_range = .2
        print(time.strftime('%c')+' - Initialized.')
    
    def get_resistance(self):
        open_busy(self.ilx)
        self.ilx.write(self.tec_open_cmd)
        res = self.ilx.query('TEC:R?').strip()
        self.ilx.close()
        return float(res)
    
    def set_resistance(self, resistance):
        open_busy(self.ilx)
        self.ilx.write(self.tec_open_cmd)
        self.ilx.write('TEC:R {:.3f}'.format(resistance))
        self.ilx.close()
        
    def get_resistance_setpoint(self):
        open_busy(self.ilx)
        self.ilx.write(self.tec_open_cmd)
        res = self.ilx.query('TEC:SET:R?').strip()
        self.ilx.close()
        return float(res)
    
    def set_tec_step(self, step):
        open_busy(self.ilx)
        self.ilx.write(self.tec_open_cmd)
        self.ilx.write('TEC:STEP {:}'.format(int(step)))
        self.ilx.close()
    
    def dec_tec(self):
        open_busy(self.ilx)
        self.ilx.write(self.tec_open_cmd)
        self.ilx.write('TEC:DEC')
        self.ilx.close()
    
    def inc_tec(self):
        open_busy(self.ilx)
        self.ilx.write(self.tec_open_cmd)
        self.ilx.write('TEC:INC')
        self.ilx.close()
    
    def change_tec_output(self, direction):
        now = time.time()
        if now - self.last_tec_change > 1:
            old_res = self.get_resistance()
            new_res = old_res
            while abs(new_res - old_res) < .002:
                if direction>0:
                    if new_res - (self.nominal_tec_r+self.safe_tec_range) < 0:
                        self.inc_tec()
                    else:
                        print(time.strftime('%c')+' - at the limit of the safe TEC range. Raising no farther.')
                        return
                elif direction<0:
                    if new_res - (self.nominal_tec_r-self.safe_tec_range) > 0:
                        self.dec_tec()
                    else:
                        print(time.strftime('%c')+' - at the limit of the safe TEC range. Lowering no farther.')
                        return
                time.sleep(.5)
                new_res = self.get_resistance()
            self.last_tec_change = time.time()
        else:
            print(time.strftime('%c')+' - TEC has not settled. {:.3f}s left'.format(now - self.last_tec_change))
        #time.sleep(20) #let the temperature settle


class ni_USB6361:
    def __init__(self, dev_channel_id, low_v = -1, high_v = 1):
        self.NSAMPS = 1000
        self.read = int32()
        self.data = np.zeros( (self.NSAMPS,), dtype = np.float64)
        self.t = Task()
        self.t.CreateAIVoltageChan(dev_channel_id, "", DAQmx_Val_RSE, low_v, high_v, DAQmx_Val_Volts, None)
    
    def read_analog(self):
        start_busy(self.t)
        self.t.ReadAnalogF64(self.NSAMPS, 10.0, DAQmx_Val_GroupByChannel, self.data, self.NSAMPS, byref(self.read), None)
        self.t.StopTask()
    
    def get_peak_freq(self):
        self.read_analog()
        han_win = np.hanning(self.NSAMPS)
        freqs = 1e4*np.fft.rfftfreq(self.NSAMPS)
        amps = np.abs(np.fft.rfft(han_win*self.data))
        peak_ind = np.argmax(amps)
        return freqs[peak_ind]
    
    def get_rms(self):
        self.read_analog()
        rms = np.sqrt(np.mean(np.square(self.data)))
        return rms


class srs_SIM900:
    def __init__(self, visa_id, channel, rm = None, thrsh_1 = .2, thrsh_2 = .05):
        print(time.strftime('%c')+' - Initializing communication with the SRS SIM900.')
        if rm is None:
            rm = visa.ResourceManager()
        opened = False
        while not opened:
            try:
                self.srs = rm.open_resource(visa_id, open_timeout = 5000)
            except visa.VisaIOError as visa_err:
                if visa_err[0] == visa.VisaIOError(visa.constants.VI_ERROR_RSRC_BUSY)[0]:
                    pass
                else:
                    raise
            else:
                opened = True
        self.srs.close()
        self.flush()
        self.open_cmd = 'CONN '+str(channel)+',"xyz"\n'
        # Get settings (from instrument or database?)
        self.ulim, self.llim = self.get_output_lims()
        self.center = np.mean([self.ulim, self.llim])
        self.threshold_1 = (self.ulim - self.llim)*(1.-thrsh_1*2.)/2.
        self.threshold_2 = (self.ulim - self.llim)*(1.-thrsh_2*2.)/2.
        print(time.strftime('%c')+' - Initialized.')
    
    def flush(self):
        open_busy(self.srs)
        self.srs.flush(visa.constants.VI_READ_BUF)
        self.srs.close()
    
    def get_man_output(self):
        open_busy(self.srs)
        self.srs.write(self.open_cmd)
        man_output = self.srs.query('MOUT?').strip()
        self.srs.write('xyz')
        self.srs.close()
        return float(man_output)
    
    def set_man_output(self, output):
        open_busy(self.srs)
        self.srs.write(self.open_cmd)
        self.srs.write('MOUT {:.3f}'.format(output))
        self.srs.write('xyz')
        self.srs.close()
    
    def get_output(self):
        open_busy(self.srs)
        self.srs.write(self.open_cmd)
        level = self.srs.query('OMON?\n').strip()
        self.srs.write('xyz')
        self.srs.close()
        return float(level)
    
    def get_output_cond(self):
        open_busy(self.srs)
        self.srs.write(self.open_cmd)
        u_lim = self.srs.query('INCR? 1').strip()
        l_lim = self.srs.query('INCR? 2').strip()
        anti_wind = self.srs.query('INCR? 3').strip()
        self.srs.write('xyz')
        self.srs.close()
        return [int(u_lim), int(l_lim), int(anti_wind)]
    
    def get_output_lims(self):
        open_busy(self.srs)
        self.srs.write(self.open_cmd)
        ulim = self.srs.query('ULIM?\n').strip()
        llim = self.srs.query('LLIM?\n').strip()
        self.srs.write('xyz')
        self.srs.close()
        return [float(ulim), float(llim)]
    
    def get_pid_state(self):
        open_busy(self.srs)
        self.srs.write(self.open_cmd)
        state = self.srs.query("AMAN?\n").strip()
        self.srs.write('xyz')
        self.srs.close()
        return int(state)
    
    def set_pid_state(self, state):
        open_busy(self.srs)
        self.srs.write(self.open_cmd)
        self.srs.write("AMAN {:}\n".format(int(state)))
        self.srs.write('xyz')
        self.srs.close()


def get_lock(srs, daq, ilx, last_good_pos = None):
    #Turn off PID servo
    srs.set_pid_state(0)
    srs.set_man_output(srs.center - srs.threshold_2) # reset the hysteresis
    #Try locking at last good position
    if last_good_pos is not None:
        srs.set_man_output(last_good_pos)
        time.sleep(.1)
        srs.set_pid_state(1)
        time.sleep(1)
        current_output = srs.get_output()
        if abs(current_output - srs.center) < srs.threshold_2:
            return
        else:
            srs.set_pid_state(0)
    
    #Find lock point    
    to_fit = lambda v, v0, s: s*np.abs(v-v0)
        #Get Data
    x = np.linspace(srs.center-srs.threshold_2, srs.center+srs.threshold_2, 4)
    y =np.copy(x)
    for ind, x_val in enumerate(x):
        srs.set_man_output(x_val)
        y[ind] = daq.get_peak_freq()
    srs.set_man_output(x[0]) # reset the hysteresis
        #Coarse Estimate
    slopes = np.diff(y)/np.diff(x)
    slope_ind = np.argmax(np.abs(slopes))
    output_coarse = -y[slope_ind]/slopes[slope_ind] + x[slope_ind]
    slope_coarse = np.abs(slopes[slope_ind])
        #Fine Estimate
    try:
        new_output = curve_fit(to_fit, x, y, [output_coarse, slope_coarse])[0][0]
    except:
        print(time.strftime('%c')+' - Curve fit failed')
        new_output = srs.center
    
    #Get Lock
    if abs(new_output - srs.center) < srs.threshold_2:
        print(time.strftime('%c')+' - estimated voltage setpoint = {:.3f}, locking.'.format(new_output))
        srs.set_man_output(new_output)
        time.sleep(.1)
        srs.set_pid_state(1)
    elif new_output < srs.center:
        print(time.strftime('%c')+' - estimated voltage setpoint = {:.3f}, raising the resistance setpoint.'.format(new_output))
        ilx.change_tec_output(+1)
        #time.sleep(30)
    elif new_output > srs.center:
        print(time.strftime('%c')+' - estimated voltage setpoint = {:.3f}, lowering the resistance setpoint.'.format(new_output))
        ilx.change_tec_output(-1)
        #time.sleep(30)


# %% Setup
rm = visa.ResourceManager()

fr_pid = srs_SIM900('ASRL9::INSTR', 1, rm)
fr_err = ni_USB6361('Dev1/ai0')
fr_tec = ilx_LDC3900(u'GPIB0::20::INSTR', 1, rm)

last_good_pos = None

#pid_ulim, pid_llim = fr_pid.get_output_lims()
#
#pid_center = np.mean([pid_ulim, pid_llim])
#pid_hyst = (pid_ulim - pid_llim)*(1.-.2*2.)/2.
#pid_hyst2 = (pid_ulim - pid_llim)*(1.-.01*2.)/2.

# %% Test

test = 0
while test:
    #Begin Test
    if fr_pid.get_pid_state():
        current_output = fr_pid.get_output()
        current_output_cond = fr_pid.get_output_cond()
        current_rms = fr_err.get_rms()
        print current_output
        print current_output_cond
        print current_rms
        if abs(current_output - fr_pid.center) > fr_pid.threshold_2:
            print(time.strftime('%c')+' - lost fR lock')
            get_lock(fr_pid, fr_err, fr_tec, last_good_pos)
        elif abs(current_output - fr_pid.center) > fr_pid.threshold_1:
            if current_output - fr_pid.center > 0:
                print(time.strftime('%c')+' - voltage was {:.3f}, lowering the resistance setpoint.'.format(current_output))
                fr_tec.change_tec_output(-1)
            elif current_output - fr_pid.center < 0:
                print(time.strftime('%c')+' - voltage was {:.3f}, raising the resistance setpoint.'.format(current_output))
                fr_tec.change_tec_output(1)
        else:
            last_good_pos = current_output
    else:
        get_lock(fr_pid, fr_err, fr_tec)
    time.sleep(.1)
    #End Test
    test = 0
    


# %% Main Loop

while 1:
    if fr_pid.get_pid_state():
        current_output = fr_pid.get_output()
        current_output_cond = fr_pid.get_output_cond()
        if abs(current_output - fr_pid.center) > fr_pid.threshold_2:
            print(time.strftime('%c')+' - lost fR lock')
            get_lock(fr_pid, fr_err, fr_tec, last_good_pos)
        elif abs(current_output - fr_pid.center) > fr_pid.threshold_1:
            if current_output - fr_pid.center > 0:
                print(time.strftime('%c')+' - voltage was {:.3f}, lowering the resistance setpoint.'.format(current_output))
                fr_tec.change_tec_output(-1)
            elif current_output - fr_pid.center < 0:
                print(time.strftime('%c')+' - voltage was {:.3f}, raising the resistance setpoint.'.format(current_output))
                fr_tec.change_tec_output(+1)
        else:
            last_good_pos = current_output
    else:
        get_lock(fr_pid, fr_err, fr_tec)


print('temperature setpoint is out of range')


    